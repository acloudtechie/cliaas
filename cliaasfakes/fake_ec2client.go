// This file was generated by counterfeiter
package cliaasfakes

import (
	"sync"

	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/pivotal-cf/cliaas"
)

type FakeEC2Client struct {
	DescribeInstancesStub        func(*ec2.DescribeInstancesInput) (*ec2.DescribeInstancesOutput, error)
	describeInstancesMutex       sync.RWMutex
	describeInstancesArgsForCall []struct {
		arg1 *ec2.DescribeInstancesInput
	}
	describeInstancesReturns struct {
		result1 *ec2.DescribeInstancesOutput
		result2 error
	}
	DescribeInstanceStatusStub        func(*ec2.DescribeInstanceStatusInput) (*ec2.DescribeInstanceStatusOutput, error)
	describeInstanceStatusMutex       sync.RWMutex
	describeInstanceStatusArgsForCall []struct {
		arg1 *ec2.DescribeInstanceStatusInput
	}
	describeInstanceStatusReturns struct {
		result1 *ec2.DescribeInstanceStatusOutput
		result2 error
	}
	AssociateAddressStub        func(*ec2.AssociateAddressInput) (*ec2.AssociateAddressOutput, error)
	associateAddressMutex       sync.RWMutex
	associateAddressArgsForCall []struct {
		arg1 *ec2.AssociateAddressInput
	}
	associateAddressReturns struct {
		result1 *ec2.AssociateAddressOutput
		result2 error
	}
	TerminateInstancesStub        func(*ec2.TerminateInstancesInput) (*ec2.TerminateInstancesOutput, error)
	terminateInstancesMutex       sync.RWMutex
	terminateInstancesArgsForCall []struct {
		arg1 *ec2.TerminateInstancesInput
	}
	terminateInstancesReturns struct {
		result1 *ec2.TerminateInstancesOutput
		result2 error
	}
	StopInstancesStub        func(*ec2.StopInstancesInput) (*ec2.StopInstancesOutput, error)
	stopInstancesMutex       sync.RWMutex
	stopInstancesArgsForCall []struct {
		arg1 *ec2.StopInstancesInput
	}
	stopInstancesReturns struct {
		result1 *ec2.StopInstancesOutput
		result2 error
	}
	StartInstancesStub        func(*ec2.StartInstancesInput) (*ec2.StartInstancesOutput, error)
	startInstancesMutex       sync.RWMutex
	startInstancesArgsForCall []struct {
		arg1 *ec2.StartInstancesInput
	}
	startInstancesReturns struct {
		result1 *ec2.StartInstancesOutput
		result2 error
	}
	CreateTagsStub        func(*ec2.CreateTagsInput) (*ec2.CreateTagsOutput, error)
	createTagsMutex       sync.RWMutex
	createTagsArgsForCall []struct {
		arg1 *ec2.CreateTagsInput
	}
	createTagsReturns struct {
		result1 *ec2.CreateTagsOutput
		result2 error
	}
	RunInstancesStub        func(*ec2.RunInstancesInput) (*ec2.Reservation, error)
	runInstancesMutex       sync.RWMutex
	runInstancesArgsForCall []struct {
		arg1 *ec2.RunInstancesInput
	}
	runInstancesReturns struct {
		result1 *ec2.Reservation
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEC2Client) DescribeInstances(arg1 *ec2.DescribeInstancesInput) (*ec2.DescribeInstancesOutput, error) {
	fake.describeInstancesMutex.Lock()
	fake.describeInstancesArgsForCall = append(fake.describeInstancesArgsForCall, struct {
		arg1 *ec2.DescribeInstancesInput
	}{arg1})
	fake.recordInvocation("DescribeInstances", []interface{}{arg1})
	fake.describeInstancesMutex.Unlock()
	if fake.DescribeInstancesStub != nil {
		return fake.DescribeInstancesStub(arg1)
	} else {
		return fake.describeInstancesReturns.result1, fake.describeInstancesReturns.result2
	}
}

func (fake *FakeEC2Client) DescribeInstancesCallCount() int {
	fake.describeInstancesMutex.RLock()
	defer fake.describeInstancesMutex.RUnlock()
	return len(fake.describeInstancesArgsForCall)
}

func (fake *FakeEC2Client) DescribeInstancesArgsForCall(i int) *ec2.DescribeInstancesInput {
	fake.describeInstancesMutex.RLock()
	defer fake.describeInstancesMutex.RUnlock()
	return fake.describeInstancesArgsForCall[i].arg1
}

func (fake *FakeEC2Client) DescribeInstancesReturns(result1 *ec2.DescribeInstancesOutput, result2 error) {
	fake.DescribeInstancesStub = nil
	fake.describeInstancesReturns = struct {
		result1 *ec2.DescribeInstancesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) DescribeInstanceStatus(arg1 *ec2.DescribeInstanceStatusInput) (*ec2.DescribeInstanceStatusOutput, error) {
	fake.describeInstanceStatusMutex.Lock()
	fake.describeInstanceStatusArgsForCall = append(fake.describeInstanceStatusArgsForCall, struct {
		arg1 *ec2.DescribeInstanceStatusInput
	}{arg1})
	fake.recordInvocation("DescribeInstanceStatus", []interface{}{arg1})
	fake.describeInstanceStatusMutex.Unlock()
	if fake.DescribeInstanceStatusStub != nil {
		return fake.DescribeInstanceStatusStub(arg1)
	} else {
		return fake.describeInstanceStatusReturns.result1, fake.describeInstanceStatusReturns.result2
	}
}

func (fake *FakeEC2Client) DescribeInstanceStatusCallCount() int {
	fake.describeInstanceStatusMutex.RLock()
	defer fake.describeInstanceStatusMutex.RUnlock()
	return len(fake.describeInstanceStatusArgsForCall)
}

func (fake *FakeEC2Client) DescribeInstanceStatusArgsForCall(i int) *ec2.DescribeInstanceStatusInput {
	fake.describeInstanceStatusMutex.RLock()
	defer fake.describeInstanceStatusMutex.RUnlock()
	return fake.describeInstanceStatusArgsForCall[i].arg1
}

func (fake *FakeEC2Client) DescribeInstanceStatusReturns(result1 *ec2.DescribeInstanceStatusOutput, result2 error) {
	fake.DescribeInstanceStatusStub = nil
	fake.describeInstanceStatusReturns = struct {
		result1 *ec2.DescribeInstanceStatusOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) AssociateAddress(arg1 *ec2.AssociateAddressInput) (*ec2.AssociateAddressOutput, error) {
	fake.associateAddressMutex.Lock()
	fake.associateAddressArgsForCall = append(fake.associateAddressArgsForCall, struct {
		arg1 *ec2.AssociateAddressInput
	}{arg1})
	fake.recordInvocation("AssociateAddress", []interface{}{arg1})
	fake.associateAddressMutex.Unlock()
	if fake.AssociateAddressStub != nil {
		return fake.AssociateAddressStub(arg1)
	} else {
		return fake.associateAddressReturns.result1, fake.associateAddressReturns.result2
	}
}

func (fake *FakeEC2Client) AssociateAddressCallCount() int {
	fake.associateAddressMutex.RLock()
	defer fake.associateAddressMutex.RUnlock()
	return len(fake.associateAddressArgsForCall)
}

func (fake *FakeEC2Client) AssociateAddressArgsForCall(i int) *ec2.AssociateAddressInput {
	fake.associateAddressMutex.RLock()
	defer fake.associateAddressMutex.RUnlock()
	return fake.associateAddressArgsForCall[i].arg1
}

func (fake *FakeEC2Client) AssociateAddressReturns(result1 *ec2.AssociateAddressOutput, result2 error) {
	fake.AssociateAddressStub = nil
	fake.associateAddressReturns = struct {
		result1 *ec2.AssociateAddressOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) TerminateInstances(arg1 *ec2.TerminateInstancesInput) (*ec2.TerminateInstancesOutput, error) {
	fake.terminateInstancesMutex.Lock()
	fake.terminateInstancesArgsForCall = append(fake.terminateInstancesArgsForCall, struct {
		arg1 *ec2.TerminateInstancesInput
	}{arg1})
	fake.recordInvocation("TerminateInstances", []interface{}{arg1})
	fake.terminateInstancesMutex.Unlock()
	if fake.TerminateInstancesStub != nil {
		return fake.TerminateInstancesStub(arg1)
	} else {
		return fake.terminateInstancesReturns.result1, fake.terminateInstancesReturns.result2
	}
}

func (fake *FakeEC2Client) TerminateInstancesCallCount() int {
	fake.terminateInstancesMutex.RLock()
	defer fake.terminateInstancesMutex.RUnlock()
	return len(fake.terminateInstancesArgsForCall)
}

func (fake *FakeEC2Client) TerminateInstancesArgsForCall(i int) *ec2.TerminateInstancesInput {
	fake.terminateInstancesMutex.RLock()
	defer fake.terminateInstancesMutex.RUnlock()
	return fake.terminateInstancesArgsForCall[i].arg1
}

func (fake *FakeEC2Client) TerminateInstancesReturns(result1 *ec2.TerminateInstancesOutput, result2 error) {
	fake.TerminateInstancesStub = nil
	fake.terminateInstancesReturns = struct {
		result1 *ec2.TerminateInstancesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) StopInstances(arg1 *ec2.StopInstancesInput) (*ec2.StopInstancesOutput, error) {
	fake.stopInstancesMutex.Lock()
	fake.stopInstancesArgsForCall = append(fake.stopInstancesArgsForCall, struct {
		arg1 *ec2.StopInstancesInput
	}{arg1})
	fake.recordInvocation("StopInstances", []interface{}{arg1})
	fake.stopInstancesMutex.Unlock()
	if fake.StopInstancesStub != nil {
		return fake.StopInstancesStub(arg1)
	} else {
		return fake.stopInstancesReturns.result1, fake.stopInstancesReturns.result2
	}
}

func (fake *FakeEC2Client) StopInstancesCallCount() int {
	fake.stopInstancesMutex.RLock()
	defer fake.stopInstancesMutex.RUnlock()
	return len(fake.stopInstancesArgsForCall)
}

func (fake *FakeEC2Client) StopInstancesArgsForCall(i int) *ec2.StopInstancesInput {
	fake.stopInstancesMutex.RLock()
	defer fake.stopInstancesMutex.RUnlock()
	return fake.stopInstancesArgsForCall[i].arg1
}

func (fake *FakeEC2Client) StopInstancesReturns(result1 *ec2.StopInstancesOutput, result2 error) {
	fake.StopInstancesStub = nil
	fake.stopInstancesReturns = struct {
		result1 *ec2.StopInstancesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) StartInstances(arg1 *ec2.StartInstancesInput) (*ec2.StartInstancesOutput, error) {
	fake.startInstancesMutex.Lock()
	fake.startInstancesArgsForCall = append(fake.startInstancesArgsForCall, struct {
		arg1 *ec2.StartInstancesInput
	}{arg1})
	fake.recordInvocation("StartInstances", []interface{}{arg1})
	fake.startInstancesMutex.Unlock()
	if fake.StartInstancesStub != nil {
		return fake.StartInstancesStub(arg1)
	} else {
		return fake.startInstancesReturns.result1, fake.startInstancesReturns.result2
	}
}

func (fake *FakeEC2Client) StartInstancesCallCount() int {
	fake.startInstancesMutex.RLock()
	defer fake.startInstancesMutex.RUnlock()
	return len(fake.startInstancesArgsForCall)
}

func (fake *FakeEC2Client) StartInstancesArgsForCall(i int) *ec2.StartInstancesInput {
	fake.startInstancesMutex.RLock()
	defer fake.startInstancesMutex.RUnlock()
	return fake.startInstancesArgsForCall[i].arg1
}

func (fake *FakeEC2Client) StartInstancesReturns(result1 *ec2.StartInstancesOutput, result2 error) {
	fake.StartInstancesStub = nil
	fake.startInstancesReturns = struct {
		result1 *ec2.StartInstancesOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) CreateTags(arg1 *ec2.CreateTagsInput) (*ec2.CreateTagsOutput, error) {
	fake.createTagsMutex.Lock()
	fake.createTagsArgsForCall = append(fake.createTagsArgsForCall, struct {
		arg1 *ec2.CreateTagsInput
	}{arg1})
	fake.recordInvocation("CreateTags", []interface{}{arg1})
	fake.createTagsMutex.Unlock()
	if fake.CreateTagsStub != nil {
		return fake.CreateTagsStub(arg1)
	} else {
		return fake.createTagsReturns.result1, fake.createTagsReturns.result2
	}
}

func (fake *FakeEC2Client) CreateTagsCallCount() int {
	fake.createTagsMutex.RLock()
	defer fake.createTagsMutex.RUnlock()
	return len(fake.createTagsArgsForCall)
}

func (fake *FakeEC2Client) CreateTagsArgsForCall(i int) *ec2.CreateTagsInput {
	fake.createTagsMutex.RLock()
	defer fake.createTagsMutex.RUnlock()
	return fake.createTagsArgsForCall[i].arg1
}

func (fake *FakeEC2Client) CreateTagsReturns(result1 *ec2.CreateTagsOutput, result2 error) {
	fake.CreateTagsStub = nil
	fake.createTagsReturns = struct {
		result1 *ec2.CreateTagsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) RunInstances(arg1 *ec2.RunInstancesInput) (*ec2.Reservation, error) {
	fake.runInstancesMutex.Lock()
	fake.runInstancesArgsForCall = append(fake.runInstancesArgsForCall, struct {
		arg1 *ec2.RunInstancesInput
	}{arg1})
	fake.recordInvocation("RunInstances", []interface{}{arg1})
	fake.runInstancesMutex.Unlock()
	if fake.RunInstancesStub != nil {
		return fake.RunInstancesStub(arg1)
	} else {
		return fake.runInstancesReturns.result1, fake.runInstancesReturns.result2
	}
}

func (fake *FakeEC2Client) RunInstancesCallCount() int {
	fake.runInstancesMutex.RLock()
	defer fake.runInstancesMutex.RUnlock()
	return len(fake.runInstancesArgsForCall)
}

func (fake *FakeEC2Client) RunInstancesArgsForCall(i int) *ec2.RunInstancesInput {
	fake.runInstancesMutex.RLock()
	defer fake.runInstancesMutex.RUnlock()
	return fake.runInstancesArgsForCall[i].arg1
}

func (fake *FakeEC2Client) RunInstancesReturns(result1 *ec2.Reservation, result2 error) {
	fake.RunInstancesStub = nil
	fake.runInstancesReturns = struct {
		result1 *ec2.Reservation
		result2 error
	}{result1, result2}
}

func (fake *FakeEC2Client) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.describeInstancesMutex.RLock()
	defer fake.describeInstancesMutex.RUnlock()
	fake.describeInstanceStatusMutex.RLock()
	defer fake.describeInstanceStatusMutex.RUnlock()
	fake.associateAddressMutex.RLock()
	defer fake.associateAddressMutex.RUnlock()
	fake.terminateInstancesMutex.RLock()
	defer fake.terminateInstancesMutex.RUnlock()
	fake.stopInstancesMutex.RLock()
	defer fake.stopInstancesMutex.RUnlock()
	fake.startInstancesMutex.RLock()
	defer fake.startInstancesMutex.RUnlock()
	fake.createTagsMutex.RLock()
	defer fake.createTagsMutex.RUnlock()
	fake.runInstancesMutex.RLock()
	defer fake.runInstancesMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeEC2Client) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cliaas.EC2Client = new(FakeEC2Client)
